\documentclass{template}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{appendix}
\usepackage{float}
\usepackage{shorttoc}

\begin{document}
\title{32位MIPS处理器实验设计文档}
\author{SHS小组 \\ 乔奕~郭嘉丞~陈雨兰}
\maketitle
%\tableofcontents
\shorttableofcontents{目录}{2}
\newpage

\section{引言}

    \subsection{编写目的}
    在之前编写的需求文档中，已经对此次实验的需求和关键技术处理作了原理性的说明，在此基础上编写设计文档，明确各模块的接口和具体实现，指导实际的代码开发过程。

    \subsection{开发环境}
    编程语言：vhdl
    
    硬件系统：清华大学计算机系32位系统开发板
    
    操作系统：ucore

    \subsection{参考资料}
    《实验指导文档》

    《计算机组成与设计~硬件/软件接口》
    
    《See MIPS Run》

\section{模块设计}

    \subsection{ALU}
    \begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{CPUPic/ALU.jpg}
    \end{figure}
    
    \begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|}
    \hline
    信号 & 描述  \\
    \hline
    alu_opcode &  \\
    \hline
    2 & EntryLo0 & 作为 TLBWI 及其他 TLB 指令接口，管理偶数页入口  \\
    \hline
    3 & EntryLo1 & 作为 TLBWI 及其他 TLB 指令接口，管理奇数页入口  \\
    \hline
    9 & BadVAddr & 捕捉最近一次地址错误或 TLB 异常时的虚拟地址  \\
    \hline
    10 & Count & 每隔一个时时增加 1，用作计时器，并可使能控制  \\
    \hline
    \multirow{2}{*}{11} & \multirow{2}{*}{EntryHi} & TLB 异常时，系统将虚拟地址部分写入 EntryHi 寄存器中用于 TLB 匹 \\
    & & 配信息  \\
    \hline
    \multirow{2}{*}{12} & \multirow{2}{*}{Compare} & Compare 保持一定值，当 Count 值与 Compare 相等时，SI\_TimerInt 引 \\
    & & 脚变高电平直到有数值写入 Compare，用于定时中断 \\
    \hline
    13 & Status & 表示处理器的操作模式、中断使能及诊断状态  \\
    \hline
    15 & Cause & 记录最近一次异常原因，控制软件中断请求和中断处理派分向量  \\
    \hline
    16 & EPC & 存储异常处理之后程序恢复执行的地址  \\
    \hline
    18 & EBase & 识别多处理器系统中不同的处理器异常向量的基地址  \\
    \hline
    \end{tabular}
    \end{table}
    
    ALU 负责双操作数的算术逻辑运算，由 ALUOp 信号和指令的 funct 字段控制，完成数据和地址的算术、逻辑、移位运算，输出结果。其中，乘法指令不通过 ALU 计算，由乘法器支持，PC + 4 运算由专门的加法器支持。

    为支持流水线 CPU 的正常运行，部分运算如跳转指令的地址计算不通过 ALU 。


    \subsection{寄存器堆}
    对于 32 位 MIPS 系统，需要在寄存器堆中实现 32 个通用 32 位寄存器，在指令解码阶段读取寄存器内容，在写回阶段完成写入。

    \subsection{CP0}
    系统控制协处理器 CP0 主要提供管理 CPU 资源所需的机制，包括 MMU、TLB 与异常处理控制。通过调用 MFC0，MTC0 指令，CP0 提供了统一的对外接口以完成对寄存器组的访问。

    下表为需要实现的 CP0 寄存器及其主要功能。

    \begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|}
    \hline
    编号 & 寄存器名称 & 寄存器功能  \\
    \hline
    0 & Index & 用于 TLBWI 指令访问 TLB 入口的索引序号  \\
    \hline
    2 & EntryLo0 & 作为 TLBWI 及其他 TLB 指令接口，管理偶数页入口  \\
    \hline
    3 & EntryLo1 & 作为 TLBWI 及其他 TLB 指令接口，管理奇数页入口  \\
    \hline
    9 & BadVAddr & 捕捉最近一次地址错误或 TLB 异常时的虚拟地址  \\
    \hline
    10 & Count & 每隔一个时时增加 1，用作计时器，并可使能控制  \\
    \hline
    \multirow{2}{*}{11} & \multirow{2}{*}{EntryHi} & TLB 异常时，系统将虚拟地址部分写入 EntryHi 寄存器中用于 TLB 匹 \\
    & & 配信息  \\
    \hline
    \multirow{2}{*}{12} & \multirow{2}{*}{Compare} & Compare 保持一定值，当 Count 值与 Compare 相等时，SI\_TimerInt 引 \\
    & & 脚变高电平直到有数值写入 Compare，用于定时中断 \\
    \hline
    13 & Status & 表示处理器的操作模式、中断使能及诊断状态  \\
    \hline
    15 & Cause & 记录最近一次异常原因，控制软件中断请求和中断处理派分向量  \\
    \hline
    16 & EPC & 存储异常处理之后程序恢复执行的地址  \\
    \hline
    18 & EBase & 识别多处理器系统中不同的处理器异常向量的基地址  \\
    \hline
    \end{tabular}
    \end{table}

        \subsubsection{Index}
        Index 寄存器是一个 32 位的读/写寄存器，可用于 TLBP、TLBR 和 TLBWI 指令访访 TLB 入口的索引序号。
        \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|l|l|}
        \hline
        比特位&描述&读/写&重置状态 \\
        \hline
        31&检测故障，TLPB指令没有在TLB中寻得匹配时置1 & R/W &未定义 \\
        \hline
        30:6&必须写为0，读取返回0 & 0 & 0\\
        \hline
        5:0&TLB入口索引，受TLBRead和TLBWrite影响 & R/W & 未定义 \\
        \hline
        \end{tabular}
        \end{table}

        \subsubsection{EntryLo1/EntryLo0}
        EntryLo 寄存器的作用等同于TLB、TLBR、TLBWI 和 TLBWR 指令时的接口。选基于 TLB 的 MMU 而言，EntryLo0 管理偶数页的 入口，EntryLo1 管理奇数页的入口。如果出现地址错误，TLB 失效，TLB 修改或是TLB 重填异常的行为，寄存器的内容将成为未定义的。
        \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|l|l|}
        \hline
        比特位&描述&读/写&重置状态 \\
        \hline
        31:30&保留区域，写入忽略，读取返回0& R &0 \\
        \hline
        29:26&强制写入0 & R & 0\\
        \hline
        25:6&页帧号PFN，对应了物理地址31:12位 & R/W & 未定义\\
        \hline
        5:3&页面一致性属性C & R/W & 未定义 \\
        \hline
        2& 写使能位D，D=1则允许写入该页 & R/W & 未定义 \\
        \hline
        1& 有效位V，V=1则允许访问该页，V=0引起TLB无效异常 & R/W & 未定义 \\
        \hline
        \multirow{2}{*}{0} & 全局位G，两个寄存器的G位共同决定TLB匹配中是否忽 & \multirow{2}{*}{R/W} & \multirow{2}{*}{未定义} \\
         & 略ASID比较& & \\
        \hline
        \end{tabular}
        \end{table}

        \subsubsection{EntryHi}
        EntryHi 寄存器包含了用于 TLB 读、写和访问操作的虚拟地址匹配信息。当 TLB 异常发生时，系统将虚拟地址的[31:13]位写入 EntryHi 寄存器的 VPN2 区域。TLBR 指令将选中的 TLB 入口相应的区域写入 EntryHi 寄存器。操作系统将当前地址空时标识符写入 ASID 区 域，该区域在 TLB 比较过程中用于确定 TLB 是否可以匹配。
        \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|l|l|}
        \hline
        比特位&描述&读/写&重置状态 \\
        \hline
        31:13 & VPN2，TLB异常时由硬件写入 & R/W & 未定义 \\
        \hline
        12:8 & 必须写入0，返回0 & 0 & 0\\
        \hline
        7:0 & 地址空间标识符ASID，在TLB读取时由硬件写入 & R/W & 未定义\\
        \hline
        \end{tabular}
        \end{table}

        \subsubsection{Status}
        Status 寄存器的区域联合作用，可以创建协理器的工作模式。
        当以下所有条件都成立时启用中断：

        Status[0]:IE = 1

        Status[0]:EXL = 0

        Status[0]:ERL = 0

        此时设置 IM（Status[16:9]）位和 IE 位可以使能中断。

        EXL 与 ERL 任一位置 1 都可使系统进入 Kernel 模式，否则为 User 模式。异常处理开始时，将 Status[1] 赋值为 1，在执行 ERET 指令时将 Status[1]赋值为 0。

        \subsubsection{Cause}
        Cause 寄存器记录了最近一次异常的原因，也控制软件中断请求以及中断处理派分的向量。
        Cause[6:2] 表示异常号。

        详情见异常处理的部分。

        \subsubsection{Count/Compare}
        每经过一个周期，Count 自增 1 ，需内置一个加法器。

        详情见异常处理的时钟中断部分。

        \subsubsection{EPC}
        如果Cause(BD)为1，也就是异常发生在延迟槽中，实际发生异常的指令就为EPC+4。但是我们返回执行的位置仍然应该是EPC，否则分枝指令的跳转就会无法执行。因此CPU必须在内部记录指令是否在延迟槽内。如果在延迟槽内的指令发生了异常，应该设置PC=EPC-4。

        \subsubsection{Ebase}
        EBase 寄存器是一个读/写寄存器，包含了在 StatusBEV 为 0 时所使用的异常向量的基地址及一个只读 CPU 号，该 CPU 号可以被软件用来区分多处理器系统中不同的处理器。
        \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|l|l|}
        \hline
        比特位&描述&读/写&重置状态 \\
        \hline
        \multirow{2}{*}{31:30} & 固定为 10，从而强制异常基地址在 kseg0 或 kseg1 的无映射的 & \multirow{2}{*}{R} & \multirow{2}{*}{10} \\
        & 虚拟地址段中& & \\
        \hline
        29:12 & 在 StatusBEV 为 0 时指定异常的基地址 & R/W & 0 \\
        \hline
        9:0 & CPUNum & R & 外部设置 \\
        \hline
        11:10 & 必须写入0，返回0 & 0 & 0\\
        \hline
        \end{tabular}
        \end{table}

    \subsection{MMU}
    内存管理单元 MMU 通过TLB异常实现。我们需要在CPU上实现一个TLB列表，每次访存需要通过TLB列表把线性地址（即虚拟地址）转化为物理地址。此外，还需要实现TLB重填的功能，包括设计若干CP0寄存器，并实现TLB重填指令 tlbwi 。

        \subsubsection{MIPS 内存地址分配}

        本实验中，地址0x80000000以上，属于kseg0区域，供操作系统内核使用，这一区域不进行map，因此，在我们实现的 MMU 中，应当判断地址是否大于0x80000000，若是，则不进行映射，若否，进入TLB查找阶段。

        从0x00000000到0x80000000是KUSEG区域，这块内存会被用于用户进程的虚存分配。

        \subsubsection{通过TLB异常实现MMU}
        CPU发起访存，使用了32位线性地址。TLB模块抽取线性地址中的前20位，作为VPN，在TLB表中查找。若查找得到，则根据表中的PPN，结合offset得到物理地址，然后直接访存。

        若无法找到，将该线性地址传入CP0中的vaddr寄存器，然后触发TLBmiss异常，进入异常处理程序。操作系统取出vaddr中的值，即访存失败的线性地址。若地址所在页表不存在，则建立新表。之后，把新表所对应的物理地址，存入CP0 寄存器中。之后，操作系统利用汇编语句直接调用tlbwi。此时，CPU根据实现了的 tlbwi 指令，利用CP0寄存器中的值，重新填充TLB中的某一项。此处，轮流重填TLB中的项（也可以随机填充）。

        MIPS 异常机制会重新执行上一条代码，此时能够正常访存。

    \subsection{异常处理}
    本实验中，由硬件检测到异常发生，填写相应的 CP0 寄存器后，跳转到操作系统的异常处理函数。操作系统根据 CP0 寄存器的值判断异常的类型，分发到相应的处理代码。

        \subsubsection{异常向量}
        MIPS32 CPU上有两组异常处理向量，根据SR(BEV)位(SR寄存器的bit22)切换：

        \paragraph{BEV==1: ROM上的异常处理}

        这是我们CPU刚刚启动时处于的状态。由于操作系统的启动还没有完成，我们的异常处理向量被放在ROM固件中。由于没有缓存系统，所以没有缓存错误的入口点。我们的CPU也没有支持EIC异常。由于我们的操作系统还没有启动，我们在实现中简单的将所有的ROM异常都直接进行无限循环。我们将会使用具体的异常向量表如下：

        \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|}
        \hline
        入口地址 & 类型 \\
        \hline
        0xBFC00200 & 简单的TLB重填 \\
        \hline
        0xBFC00380 & 其他所有异常 \\
        \hline
        \end{tabular}
        \end{table}

        \paragraph{BEV==0: RAM上的异常处理}

        当操作系统完成自己的异常向量的装载时，就会将此位置零。并且向C0寄存器堆中的EBase寄存器写入我们的异常向量的基址。
        实际上的异常向量基址Base为EBase[29:12]\&0...0，此时我们会用到的异常向量表如下：

        \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|}
        \hline
        入口地址 & 类型 \\
        \hline
        BASE+0x000 & 简单的TLB重填 \\
        \hline
        BASE+0x180 & 其他所有异常 \\
        \hline
        \end{tabular}
        \end{table}

        \subsubsection{精确异常处理流程}

        \begin{enumerate}
        \item 保存中断信息，主要是EPC，BadVAddr，Status，Cause 等寄存器的信息。

        EPC：存储异常处理之后程序恢复执行的地址。对于一般异常，当前发生错误的指令地址即为 EPC 应当保存的地址；而对于硬件中断，由于是异步产生，则可以任意设定一条并未执行完成的指令地址保存，但在进入下一步处理之前，该指令前的指令都应当被执行完。

        BadVAddr：捕捉最近一次地址错误或 TLB 异常（重填、失效、修改）时的虚拟地址。

        Status：将 EXL 位置为 1，进入 kernel 模式进行中断处理

        Cause：记下异常号。

        EnrtyHi：tlb 异常时，记下 BadVAddr 的部分高位。

        \item 根据 Cause 中的异常号跳转到相应的异常处理函数入口
        \item 中断处理
        \item 通过调用 ERET 指令恢复现场，返回 EPC 所存地址执行并且将 Status 中的 EXL 重置为 0 表示进入 user 模式。
        \end{enumerate}

        \subsubsection{异常描述}
        异常与中断列表如下：
        \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|l|}
        \hline
        异常号 & 异常名 & 描述 \\
        \hline
        0 & Interrupt & 外部中断，异步发生，由硬件引起 \\
        \hline
        1 & TLB Modified & 内存修改异常，发生在 Memory 阶段 \\
        \hline
        2 & TLBL & 读未在 TLB 中映射的内存地址触发的异常 \\
        \hline
        3 & TLBS & 写未在 TLB 中映射的内存地址触发的异常 \\
        \hline
        4 & ADEL & 读访问一个非选节地址触发的异常 \\
        \hline
        5 & ADES & 写访问一个非选节地址触发的异常 \\
        \hline
        8 & SYSCALL & 系统调用 \\
        \hline
        10 & RI & 执行未定义指令异常 \\
        \hline
        \end{tabular}
        \end{table}

        可能用到的中断号如下：
        \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|}
        \hline
        中断号 & 描述 \\
        \hline
        4 & 串口中断 \\
        \hline
        6 & 键盘中断 \\
        \hline
        7 & 时钟中断 \\
        \hline
        \end{tabular}
        \end{table}

        \subsubsection{硬件中断}
        \paragraph{时钟中断}
        由操作系统读取count寄存器并设置compare寄存器的值，Count寄存器自增到和Compare相等引起中断。此时填写cause寄存器的中断号，由操作系统处理中断。

        \paragraph{外设中断}
        与时钟中断类似，但是设置不同的硬件中断号来表示中断类别。可能涉及的外设有串口和键盘。


    \subsection{串口}

    我们预计实现如下串口功能：
    \begin{enumerate}
    \item 串口的数据地址映射到0xbfd003f8上，状态地址映射到0xbfd003fb
    \item 状态地址提供是否有新输入数据的标志位bit0，其他标志位保留
    \item 提供中断功能，当串口有新数据时引起串口异常。
    \end{enumerate}

    \subsection{指令集}
    我们采用的是 MIPS32 的标准子集作为指令集，共计 48 条指令，每一条指令是一个 32 位字。由于编译器版本不同，无法保证囊括所有所需指令，可能需要实现这 48 条以外的指令。

    具体的指令内容详见附录 A 。

    \subsection{数据通路}
    流水线的数据通路示意图如下。（出自《计算机组成与设计~硬件/软件接口》4.6 节）
    \begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{pipeline.jpg}
    \end{figure}

\section{数据通路}


\end{document}
